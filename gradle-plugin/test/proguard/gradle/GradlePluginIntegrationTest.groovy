package proguard.gradle

import org.apache.commons.io.FileUtils
import org.gradle.testkit.runner.BuildResult
import org.gradle.testkit.runner.GradleRunner
import org.gradle.testkit.runner.TaskOutcome
import org.junit.Rule
import org.junit.rules.TemporaryFolder
import spock.lang.Specification
import spock.lang.Unroll

class GradlePluginIntegrationTest extends Specification
{
    @Rule
    TemporaryFolder temporaryFolder

    @Unroll
    def "gradle plugin can be applied to spring-boot sample"()
    {
        def projectRoot = temporaryFolder.newFolder()
        def fixture = new File(getClass().classLoader.getResource('spring-boot').path)
        FileUtils.copyDirectory(fixture, projectRoot)
        TestPluginClasspath.applyToRootGradle(projectRoot)

        when:
        def result = GradleRunner.create()
            .forwardOutput()
            .withArguments('proguard')
            .withPluginClasspath()
            .withProjectDir(projectRoot)
            .build()

        then:
        result.output =~ "SUCCESSFUL"
    }

    @Unroll
    def "gradle plugin can be configured via #configOption"()
    {
        def projectRoot = temporaryFolder.newFolder()
        def fixture = new File(getClass().classLoader.getResource('gradle-kotlin-dsl').path)
        FileUtils.copyDirectory(fixture, projectRoot)
        TestPluginClasspath.applyToRootGradleKts(projectRoot)
        addConfigFileTasks(projectRoot)

        when:
        def result = runBuild(projectRoot, gradleTask)
        then:
        succeeds(result, projectRoot, gradleTask)

        // When no inputs or outputs are modified, task should be UP-TO-DATE
        when:
        result = runBuild(projectRoot, gradleTask)
        then:
        succeeds(result, projectRoot, gradleTask, TaskOutcome.UP_TO_DATE)

        // When proguard outputs are subsequently deleted, task should re-execute
        when:
        runBuild(projectRoot, "clean")
        result = runBuild(projectRoot, gradleTask)
        then:
        succeeds(result, projectRoot, gradleTask)

        // When proguard input sources are modified, task should re-execute
        when:
        def srcFile = new File(projectRoot, "src/main/java/gradlekotlindsl/App.java")
        srcFile.text = srcFile.text.replace("Hello world.", "Howdy Earth.")
        result = runBuild(projectRoot, gradleTask)
        then:
        succeeds(result, projectRoot, gradleTask)

        where:
        configOption                     | gradleTask
        "Gradle DSL"                     | "proguard"
        "Proguard config file"           | "proguardWithConfigFile"
        "generated Proguard config file" | "proguardWithGeneratedConfigFile"
    }

    private static BuildResult runBuild(File projectRoot, String... tasks)
    {
        return GradleRunner.create()
                .forwardOutput()
                .withArguments(tasks)
                .withPluginClasspath()
                .withProjectDir(projectRoot)
                .build()
    }

    private static void succeeds(BuildResult buildResult, File projectRoot, String task, TaskOutcome outcome = TaskOutcome.SUCCESS)
    {
        assert buildResult.output =~ "SUCCESSFUL"
        assert buildResult.task(":${task}").outcome == outcome
        assert new File(projectRoot, "build/${task}-obfuscated.jar").isFile()
        assert new File(projectRoot, "build/${task}-mapping.txt").isFile()
    }

    /**
     * Add extra tasks that load from a separate configuration file, including one that is generated by another task.
     * This allows us to validate that up-to-date checks work regardless of the configuration mechanism.
     */
    private static addConfigFileTasks(File projectRoot)
    {
        def buildFile = new File(projectRoot, "build.gradle.kts")
        buildFile << """
tasks.register<proguard.gradle.ProGuardTask>("proguardWithConfigFile") {
    dependsOn("jar")

    configuration("config.pro")
}

tasks.register("generateConfigFile") {
    val outputFile = file("build/proguard/config.pro")
    outputs.file(outputFile)

    doLast {
        file("build/proguard").mkdirs()
        outputFile.writeText("-basedirectory ../..\\n")
        outputFile.appendText(file("config.pro").readText().replace("proguardWithConfigFile", "proguardWithGeneratedConfigFile"))
    }
}

tasks.register<proguard.gradle.ProGuardTask>("proguardWithGeneratedConfigFile") {
    dependsOn("jar")

    // Consume the "generateConfigFile" output. This will automatically add the task dependency.
    configuration(tasks.named("generateConfigFile"))
}
"""

        def libraryJars = System.getProperty("java.version").startsWith("1.") ?
            "<java.home>/lib/rt.jar" :
            "<java.home>/jmods/java.base.jmod(!**.jar;!module-info.class)"

        def configFile = new File(projectRoot, "config.pro")
        configFile << """
-injars build/libs/gradle-kotlin-dsl.jar
-outjars build/proguardWithConfigFile-obfuscated.jar
-libraryjars ${libraryJars}

-allowaccessmodification
-repackageclasses
-printmapping build/proguardWithConfigFile-mapping.txt

-keep class gradlekotlindsl.App {
  public static void main(java.lang.String[]);
}
"""
    }
}

